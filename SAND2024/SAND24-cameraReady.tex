\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory


\usepackage{amsmath}
%\let\proof\relax
%\let\endproof\relax

\sloppy


\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage{wrapfig} %wrap the text around the picture


\usepackage{thmtools} 
\usepackage{thm-restate}

\usepackage{caption} %for subfigure - join multiple figures and add captions
%\usepackage{subcaption}
\usepackage{changepage} %inside figure we can put \begin{adjustwidth}{-1cm}{-1cm} \end{adjustwidth} and we can ignore the margins
\usepackage{mathtools} % write text [under]{over} arrow $\xrightarrow[\text{world}]{\text{hello}}$

\usepackage{graphicx}
\graphicspath{{Figures/}}

\usepackage{tikz}

\usetikzlibrary{arrows,decorations.pathmorphing,decorations.pathreplacing,backgrounds,positioning,fit,matrix}
\usetikzlibrary{shapes,calc,patterns,arrows.meta}
\tikzset{
	vert/.style={circle,inner sep=1.5,fill=white,draw,minimum size=.3cm},
	edge/.style={color=black, thick},
	diredge/.style={->,>={Stealth[width=8pt,length=8pt]},color=black, thick},
	timelabel/.style={fill=white,font=\footnotesize, text centered},
	wave/.style={decorate,decoration={coil,aspect=0}},
	dirwave/.style={->, >={Stealth[width=8pt,length=8pt]},decorate,decoration={coil,aspect=0}},
	diredge2/.style={->,>={Stealth[width=8pt,length=8pt]}}
}

%\usepackage{enumitem} %enumerate 
\usepackage{enumerate}
\usepackage{todonotes}
\newcommand{\todonkl}[2][]{\todo[color=red!100!green!33,#1]{NKL:\\ #2}} %todo note that starts with NKL:
\setlength{\marginparwidth}{3.7cm} %setting the length of todonote


\usepackage{comment}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}


%font encoding
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}

\usepackage{hyperref}

\crefname{claim}{Claim}{Claims}

%\usepackage{natbib}

\newcommand{\ie}{i.\,e.,\ }
\renewcommand{\st}{s.\,t.,\ }
\newcommand{\NP}{\textrm{NP}}
\newcommand{\APX}{\textrm{APX}}
\newcommand{\FPT}{\textrm{FPT}}
\newcommand{\XP}{\textrm{XP}}

\newcommand{\NN}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\QQ}{\mathbb{Q}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Defining a problem
%%%%%%%%%%%%%%%%%%\problemdef{NAME} {Input} {Output}
\usepackage{tabularx}
\newcommand{\problemdef}[3]{
	\begin{center}
		\begin{minipage}{0.95\textwidth}
			\noindent
			#1
			\vspace{5pt}\\
			\setlength{\tabcolsep}{3pt}
			\begin{tabularx}{\textwidth}{@{}lX@{}}
				\textbf{Input:}& #2 \\
				\textbf{Question:}& #3
			\end{tabularx}
		\end{minipage}
	\end{center}
}

\newcounter{guesscounter}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PROBLEMS NAMES
%% One label per edge, period Delta, exact realization
\newcommand{\deltaExactLong}{\textsc{Simple periodic Temporal Graph Realization}}
\newcommand{\deltaExact}{\textsc{Simple TGR}}

%% k labels per edge, period Delta, exact realization
\newcommand{\kDeltaExactLong}{\textsc{$(k,\Delta)$-periodic Exact Temporal Graph Realization}}
\newcommand{\kDeltaExact}{\textsc{$(k,\Delta)$-TGR}}

%% One label per edge, period Delta, upper-bounded realization
\newcommand{\kDeltaUpperBoundLong}{\textsc{Simple $\Delta$-periodic Upper-Bounded Temporal Graph Realization}}
%\newcommand{\deltaUpperBound}{}

%% k labels per edge, period Delta, lower-bound realization
\newcommand{\kDeltaLowerBoundLong}{\textsc{Simple $\Delta$-periodic Lower-Bounded Temporal Graph Realization}}


\bibliographystyle{plainurl}% the mandatory bibstyle
\usepackage{cite} %order citations by increasing number
\title{Temporal graph realization from fastest paths} %TODO Please add
%%%Realizing temporal graphs from fastest travel times

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Nina Klobas}{Department of Computer Science, Durham University, UK}{nina.klobas@durham.ac.uk}{ https://orcid.org/0000-0002-8024-5782}{}

\author{George B. Mertzios}{Department of Computer Science, Durham University, UK}{george.mertzios@durham.ac.uk}{https://orcid.org/0000-0001-7182-585X}{Supported by the EPSRC grant EP/P020372/1.}

\author{Hendrik~Molter}{Department of Computer Science, Ben-Gurion~University~of~the~Negev, Beer-Sheva, Israel}{molterh@post.bgu.ac.il}{https://orcid.org/0000-0002-4590-798X}{Supported by the ISF, grant No.~1456/18, and the ERC, grant number 949707.}

\author{Paul G. Spirakis}{Department of Computer Science, University of Liverpool, UK}{p.spirakis@liverpool.ac.uk}{https://orcid.org/0000-0001-5396-3749}{Supported by the EPSRC grant EP/P02002X/1.}

\authorrunning{Nina Klobas, George B. Mertzios, Hendrik Molter, and Paul G. Spirakis} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Nina Klobas, George B. Mertzios, Hendrik Molter, and Paul G. Spirakis} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Graph algorithms analysis}
\ccsdesc[500]{Mathematics of computing~Discrete mathematics}
%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Temporal graph, periodic temporal labeling, fastest temporal path, graph realization, temporal connectivity, parameterized complexity.} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\begin{document}
\maketitle

\begin{abstract}
In this paper we initiate the study of the \emph{temporal graph realization} problem with respect to the fastest path durations among its vertices, 
while we focus on periodic temporal graphs. 
Given an $n \times n$ matrix $D$ and a $\Delta \in \mathbb{N}$, the goal is to construct a $\Delta$-periodic temporal graph with $n$ vertices 
such that the duration of a \emph{fastest path} from $v_i$ to $v_j$ is equal to $D_{i,j}$, or to decide that such a temporal graph does not exist. 
The variations of the problem on static graphs has been well studied and understood since the 1960's (e.g.\ [Erd\H{o}s and Gallai, 1960], [Hakimi and Yau, 1965]).
% , and this area of research remains active until nowadays. 

As it turns out, the periodic temporal graph realization problem has a very different computational complexity behavior than its static (\ie non-temporal) counterpart. 
First we show that the problem is NP-hard in general, but polynomial-time solvable if the so-called underlying graph is a tree.
Building upon those results, we investigate its parameterized computational complexity with respect to structural parameters of the underlying static graph which measure the ``tree-likeness''. We prove a tight classification between such parameters that allow fixed-parameter tractability (FPT) 
and those which imply W[1]-hardness. 
We show that our problem is W[1]-hard when parameterized by the \emph{feedback vertex number} (and therefore also any smaller parameter such as \emph{treewidth}, \emph{degeneracy}, and \emph{cliquewidth}) of the underlying graph, while we show that it is in FPT when parameterized by the \emph{feedback edge number} (and therefore also any larger parameter such as \emph{maximum leaf number}) of the underlying graph. 





%\vspace{0,2cm}
%\noindent \textbf{Due to lack of space, the full paper with all proofs is attached in a clearly marked Appendix to be read at the discretion of the Program Committee.}
\end{abstract}

%\clearpage

\section{Introduction}\label{intro-sec}

The (static) \emph{graph realization} problem with respect to a graph property $\mathcal{P}$ is to find a graph that satisfies property $\mathcal{P}$, or to decide that no such graph exists. 
The motivation for graph realization problems stems both from ``verification'' and from network design applications in engineering. 
In \emph{verification} applications, given the outcomes of some experimental measurements (resp.~some computations) on a network, 
the aim is to (re)construct an input network which complies with them. 
If such a reconstruction is not possible, this proves that the measurements are incorrect or implausible (resp.~that the algorithm which made the computations is incorrectly implemented). 
One example of a graph realization (or reconstruction) problem is the recognition of probe interval graphs, in the context of the physical mapping of DNA, see~\cite{McMorris98,McConnellS02} and~\cite[Chapter 4]{GolumbicTrenk04}.
In \emph{network design} applications, the goal is to design network topologies having a desired property~\cite{augustine2022distributed,grotschel1995design}.
Analyzing the computational complexity of the graph realization problems for various natural and fundamental graph properties $\mathcal{P}$ requires a deep understanding of these properties.
Among the most studied such parameters for graph realization 
are constraints on the distances between vertices~\cite{barNoy2022GraphRealization,barNoy2021composed,hakimi1965distance,chung2001distance,bixby1988almost,culberson1989fast}, 
on the vertex degrees~\cite{GolovachM17,gomory1961multi,hakimi1962realizability,Bar-NoyCPR20,erdos1960graphs}, 
%%%%barNoy2021selected,cai2000solution
on the eccentricities~\cite{barNoy2020efficiently,hell2009linear,behzad1976eccentric,lesniak1975eccentric}, and on connectivity~\cite{fulkerson1960zero,frank1992augmenting,chen1966realization,frank1994connectivity,frank1970connectivity,gomory1961multi}, among others. 


In the simplest version of a (static) graph realization problem with respect to vertex distances, 
we are given a symmetric $n \times n$ matrix $D$ and we are looking for an $n$-vertex undirected and unweighted graph $G$ such that $D_{i,j}$ equals the distance between vertices $v_i$ and $v_j$ in~$G$. This problem can be trivially solved in polynomial time in two steps~\cite{hakimi1965distance}: First, we build the graph $G=(V,E)$ such that $v_i v_j \in E$ if and only if $D_{i,j}=1$. Second, from this graph $G$ we compute the matrix $D_G$ which captures the shortest distances for all pairs of vertices. If $D_G = D$ then $G$ is the desired graph, otherwise there is no graph having $D$ as its distance matrix. 
Non-trivial variations of this problem have been extensively studied, such as for weighted graphs~\cite{hakimi1965distance,Patrinos-Hakimi-72}, as well as for cases where the realizing graph has to belong to a specific graph family~\cite{hakimi1965distance, barNoy2021composed}. Other variations of the problem include the cases where every entry of the input matrix $D$ may contain a range of consecutive permissible values~\cite{barNoy2021composed,Rubei16,Tamura93}, or even an arbitrary set of acceptable values~\cite{barNoy2022GraphRealization} for the distance between the corresponding two vertices. 

In this paper we make the first attempt to understand the complexity of the graph realization problem with respect to vertex distances in the context of \emph{temporal graphs}, \ie of graphs whose \emph{topology changes over time}. 

\begin{definition}[temporal graph~\cite{KKK00}]
\label{temp-graph-def} A \emph{temporal graph} is a pair $(G,\lambda)$,
where $G=(V,E)$ is an underlying (static) graph and $\lambda :E\rightarrow 2^\mathbb{N}$ is a \emph{time-labeling} function which assigns to every edge of $G$ a set of discrete time-labels.
\end{definition}

Here, whenever $t \in \lambda(e)$, we say that the edge $e$ is \emph{active} or \emph{available} at time $t$. In the context of temporal graphs, where the notion of vertex adjacency is time-dependent, the notions of path and distance also need to be redefined. The most natural temporal analogue of a path is that of a \emph{temporal} (or \emph{time-dependent}) path, which is motivated by the fact that, due to
causality, entities and information in temporal graphs can ``flow'' only along sequences of
edges whose time-labels are strictly increasing.

\begin{definition}[fastest temporal path] \label{def:temporalPath+Duration}
Let $(G,\lambda)$ be a temporal graph. A \emph{temporal path} 
in $(G,\lambda)$ is a sequence $(e_1,t_1),(e_2,t_2),\ldots,(e_k,t_k)$, 
where $P=(e_1,\ldots,e_k)$ is a path in the underlying static graph $G$, 
%(we usually say that $P$ is the underlying path of $(P,\lambda)$), 
$t_i\in \lambda(e_i)$ for every $i=1,\ldots,k$, and $t_1<t_2<\ldots<t_k$. 
The \emph{duration} of this temporal path %$(P,\lambda)$ from $u$ to $v$ 
is $t_k - t_1 + 1$.
A \emph{fastest} temporal path from a vertex $u$ to a vertex $v$ in $(G,\lambda)$ is a temporal path from $u$ to $v$ with the smallest duration.
The \emph{duration} of the fastest temporal path from $u$ to $v$ is denoted by $d(u,v)$.
\end{definition}

%Other temporal analogues of a shortest path are temporal paths with the smallest total number of edges (\emph{shortest} temporal path), or the smallest earliest arrival time (\emph{foremost} temporal path), respectively. 







In this paper we consider \emph{periodic} temporal graphs, \ie temporal graphs in which the temporal availability of each edge of the underlying graph is periodic. 
Many natural and technological systems exhibit a periodic temporal behavior. For example, in railway networks an edge is present at a time step $t$ if and
only if a train is scheduled to run on the respective rail segment at time $t$~\cite{Arrighi2023Multi}. 
Similarly, a satellite, which makes pre-determined periodic movements, can establish a communication link (\ie a temporal edge) with another satellite whenever they are sufficiently close to each other; the existence of these communication links is also periodic. 
In a railway (resp.~satellite) network, a fastest temporal path from $u$ to $v$ represents the fastest railway connection between two stations 
(resp.~the quickest communication delay between two moving satellites). 
Furthermore, periodicity appears also in (the otherwise quite complex) social networks which describe the dynamics of people meeting~\cite{snapnets,sapiezynski2015tracking}, as every person individually follows mostly a weekly routine.%~\cite{Arrighi2023Multi}. 

Expanding the work on periodic temporal graphs
(see~\cite[Class 8]{casteigts2012time} and~\cite{Arrighi2023Multi,ErlebachS20,morawietz2021timecop,morawietz2020timecop}), 
our study represents the first attempt to understand the complexity of a graph realization problem in the context of temporal graphs. 
Therefore, we focus in this paper on the most fundamental case, where all edges have the same period $\Delta$ 
(while in the more general case, each edge $e$ in the underlying graph has a period $\Delta_e$).
As it turns out, the periodic temporal graph realization problem with respect to a given $n \times n$ matrix $D$ of the fastest duration times has a very different computational complexity behavior than the classic graph realization problem with respect to shortest path distances in static graphs. 








Formally, let $G=(V,E)$ and $\Delta\in \mathbb{N}$, and let $\lambda: E \rightarrow \{1,2,\ldots,\Delta\}$ be an edge-labeling function that assigns to every edge of $G$ exactly one of the labels from $\{1,\ldots,\Delta\}$. 
Then we denote by $(G,\lambda,\Delta)$ the \emph{$\Delta$-periodic temporal graph} $(G,L)$, where for every edge $e\in E$ we have $L(e)=\{i\Delta + x : i\geq 0, x\in \lambda(e)\}$. 
In this case we call $\lambda$ a \emph{$\Delta$-periodic labeling} of~$G$; see \cref{fig:periodic-example} for an illustration. 
When it is clear from the context, we drop $\Delta$ from the notation and 
we denote the ($\Delta$-periodic) temporal graph by $(G,\lambda)$.
Given a duration matrix~$D$, it is easy to observe that, similarly to the static case, if $D_{i,j}=1$ then $v_i$ and $v_j$ must be connected by an edge. We call the graph defined by these edges the \emph{underlying graph} of $D$.



\subparagraph{Our contribution.}
%In this work, 
We initiate the study of naturally motivated graph realization problems in the temporal setting. 
Our target is not to model unreliable communication, but instead to \emph{verify} that particular measurements regarding fastest temporal paths in a periodic temporal graph are plausible (\ie ``realizable''). 
To this end, we introduce and investigate the following problem, capturing the setting described above:
	
	
\problemdef{\deltaExactLong\ (\deltaExact)}
{An integer $n \times n$ matrix $D$, a positive integer $\Delta$.}
{Does there exist a graph $G=(V,E)$ with vertices $\{v_1,\ldots,v_{n}\}$ 
and a $\Delta$-periodic labeling $\lambda: E \rightarrow \{1,2,\ldots,\Delta\}$ such that, 
for every $i,j$, the duration of the fastest temporal path from $v_i$ to $v_j$ in the $\Delta$-periodic temporal graph $(G,\lambda,\Delta)$ is $D_{i,j}$?}


\begin{figure}[t]
    \centering
	\begin{tikzpicture}[xscale=1.5]
		%%%S_uv
		\node[vert,label=below:$v_1$] (1) at (1,0) {};
		\node[vert,label=below:$v_2$] (2) at (3,0) {};
		\node[vert,label=below:$v_3$] (3) at (5,0) {};
		\node[vert,label=below:$v_4$] (4) at (7,0) {};
		\node[vert,label=below:$v_5$] (5) at (9,0) {};
		\draw (1) -- node[label=above:$10t+7$] {} (2) -- node[label=above:$10t+3$] {}  (3) -- node[label=above:$10t+5$] {} (4) -- node[label=above:$10t+1$] {} (5);	
	\end{tikzpicture}
	\caption{An example of a $\Delta$-periodic temporal graph $(G,\lambda,\Delta)$, where $\Delta = 10$ and the 10-periodic labeling $\lambda: E \rightarrow \{1,2,\ldots,10\}$ is as follows: $\lambda(v_1 v_2)=7$, $\lambda(v_2 v_3)=3$, $\lambda(v_3 v_4)=5$, and $\lambda(v_4 v_5)=1$. 
    Here, the fastest temporal path from $v_1$ to $v_2$ traverses the first edge $v_1v_2$ at time $7$, second edge $v_2v_3$ a time $13$, third edge $v_3v_4$ at time $15$ and the last edge $v_4v_5$ at time $21$.
    This results in the total duration of $21 - 7 + 1 = 15$ for the fastest temporal path from $v_1$ to $v_5$.
	\label{fig:periodic-example}}
\end{figure}

We focus on exact algorithms. We start by showing NP-hardness of the problem (\cref{thm:NPhardness}), even if $\Delta$ is a small constant. To establish a baseline for tractability, we show that \deltaExact\ is polynomial-time solvable if the underlying graph is a tree (\cref{thm:deltaExact-PolyTimeTrees}).

Building upon these initial results, we explore the possibilities to generalize our polynomial-time algorithm using the \emph{distance-from-triviality} parameterization paradigm~\cite{FJR13,GHN04}. That is, we investigate the parameterized computational complexity of \deltaExact\ with respect to structural parameters of the underlying graph that measure its ``tree-likeness''.

We obtain the following results. We show that \deltaExact\ is W[1]-hard when parameterized by the \emph{feedback vertex number} of the underlying graph (\cref{thm:W1wrtFVS}). 
To this end, we first give a reduction from \textsc{Multicolored Clique} parameterized by the number of colors~\cite{fellows2009multipleinterval} to a variant of \deltaExact\ where the period $\Delta$ is infinite, that is, when the labeling is non-periodic. 
Then we use a special gadget (the ``infinity'' gadget) which allows us to transfer the result to a finite period $\Delta$. The latter construction is independent from the particular reduction we use, and can hence be treated as a reduction from the non-periodic to the periodic setting.
Note that our parameterized hardness result with respect to the feedback vertex number 
also implies W[1]-hardness for any smaller parameter, such as \emph{treewidth}, \emph{degeneracy}, \emph{cliquewidth}, 
\emph{distance to chordal graphs}, and \emph{distance to outerplanar graphs}.


We complement this hardness result by showing that \deltaExact\ is fixed-parameter tractable (FPT) with respect to the \emph{feedback edge number} $k$ of the underlying graph (\cref{thm:FPTwrtFES}). 
This result also implies an FPT algorithm for any larger parameter, such as the \emph{maximum leaf number}. 
A similar phenomenon of getting W[1]-hardness with respect to the feedback vertex number, while getting an FPT algorithm with respect to the feedback edge number, has been observed only in a few other temporal graph problems related to the connectivity between two vertices~\cite{casteigts2021finding,FMNR22a,EMM22}.

Our FPT algorithm works as follows on a high level. 
First we distinguish $O(k^2)$ vertices which we call ``important vertices''. 
Then, we guess the fastest temporal paths for each pair of these important vertices; as we prove, the number of choices we have for all these guesses is upper bounded by a function of~$k$. 
Then we also need to make several further guesses (again using a bounded number of choices), which altogether leads us to specify a small (\ie bounded by a function of $k$) number of different configurations for the fastest paths between \emph{all pairs} of vertices. For each of these configurations, we must then make sure that the labels of our solution will not allow any other temporal path from a vertex $v_i$ to a vertex $v_j$ have a \emph{strictly smaller} duration than~$D_{i,j}$.
This naturally leads us to build one Integer Linear Program (ILP) for each of these configurations. We manage to formulate all these ILPs by having a number of variables that is upper-bounded by a function of $k$. Finally we use Lenstra's Theorem~\cite{Lenstra1983Integer} to solve each of these ILPs in FPT time. At the end, our initial instance is a \textsc{Yes}-instance if and only if at least one of these ILPs is feasible.




The above results provide a fairly complete picture of the parameterized computational complexity of \deltaExact\ with respect to structural parameters of the underlying graph which measure ``tree-likeness''. To obtain our results, we prove several properties of fastest temporal paths, which may be of independent interest. 
Due to space constraints, proofs of results marked with $\star$ are (partially) deferred to the full version on arXiv \cite{fullPaper}.

\subparagraph{Related work.} Graph realization problems on static graphs have been studied since the 1960s. We provide an overview of the literature in the introduction. 
To the best of our knowledge, we are the first to consider graph realization problems in the temporal setting. However, many other connectivity-related problems have been studied in the temporal setting~\cite{Mertzios-transitivity21,Akrida-explorer-21,enright2021deleting,MolterRZ21,klobas2023interference,deligkas2022optimizing,erlebach2021temporal,Flu+19a,Zsc+19,CasteigtsCS22,FuchsleMNR22}, most of which are much more complex and computationally harder than their non-temporal counterparts, and some of which do not even have a non-temporal counterpart.

%There are some problem settings that share similarities with ours, which we discuss now in more detail.

Several problems have been studied where the goal is to assign labels to (sets of) edges of a given static graph in order to achieve certain connectivity-related properties~\cite{KlobasMMS22,MertziosMS19,akrida2017complexity,enright2021assigning}. The main difference to our problem setting is that in the mentioned works, the input is a graph and the sought labeling is not periodic. Furthermore, the investigated properties are temporal connectivity among all vertices~\cite{KlobasMMS22,MertziosMS19,akrida2017complexity}, temporal connectivity among a subset of vertices~\cite{KlobasMMS22}, or reducing reachability among the vertices~\cite{enright2021assigning}. In all these cases, the duration of the temporal paths has not been considered.


%work on the temporal cops and robber game~\cite{morawietz2021timecop,morawietz2020timecop,ErlebachS20}. The question here is (in its basic case) whether a certain number of cops are able to catch a robber, if everybody can move along one edge at every time step and the robber is considered caught if it occupies the same vertex as a cop at the same time. Several other works on periodic temporal graphs were mentioned in the introduction.


Finally, there are many models for dynamic networks in the context of distributed computing~\cite{Kuhn2011Dynamic}. 
These models have some similarity to temporal graphs, in the sense that in both cases the edges appear and disappear over time. 
However, there are notable differences. For example, one important assumption in the distributed setting 
can be that the edge changes are adversarial or random (while obeying some constraints such as connectivity), 
and therefore they are not necessarily known in advance~\cite{Kuhn2011Dynamic}. 


\subparagraph{Problem setting.}
We would like to point out that the choice of our setting is not unique. There exist different variations of the problem, where each one gives interesting motivation to be considered. We now briefly mention a few of them, together with some of the potential obstacles one could encounter when studying them.
As we already mentioned, the periodic temporal graphs can also be defined as temporal graphs where each edge $e$ admits a different period $\Delta_e$, or/and where each edge $e$ admits more than one time label per period $\Delta_e$.
Because of simplicity, we focus only on a case with one label per edge and a common period $\Delta$. This should give us a good understanding of the problem and potential starting points for the research of the extended versions.
In another setting, one could define the sought temporal paths differently.
First of all, we could be looking for ``non-stric'' temporal paths. These are paths with non-decreasing consecutive labels (\ie a path can traverse more than a single edge in one time step).
One of the potential drawbacks of this scenario is that the input matrix does not uniquely describe the underlying graph.
In the next modification, one could also consider foremost or shortest temporal paths, instead of the fastest temporal paths.
We believe that the complexity of the problem for these two variations does not differ significantly from the problem discussed in this paper.
Some of our proof techniques and approaches can be easily adaptable to these modified settings and therefore certain results would carry over (for example, the NP-hardness).
Lastly, the big question is why consider periodic temporal graphs and not simply just temporal graphs.
One of the reasons is the fact that a periodic temporal graph is temporally connected whenever its underlying graph is connected, and therefore the input matrix $D$ consists of all finite values (which is also true in the case of realizing ``static'' graphs).
Building upon this property, a periodic temporal graph with one label per edge is always temporally connected, while the same does not hold for a non-periodic temporal graph.
Also for the case of non-periodic temporal graphs, some of our results and approaches carry over. For example, the NP-hardness and W[1]-hardness parameterized by the feedback vertex number of the underlying graph can be easily modified for the non-periodic temporal graph setting.


\subparagraph{Preliminaries and notation.}
We already introduced the most central notion and concepts. There are some additional definitions we need, to present our proofs and results which we give in the following. 

An interval in $\mathbb N$ from $a$ to $b$ is denoted by $[a,b] = \{ i\in \mathbb N  :  a \leq i \leq b\}$; similarly, $[a] = [1,a]$.
An undirected graph~$G=(V,E)$ consists of a set~$V$ of vertices 
and a set~$E \subseteq V \times V$ of edges.
For a graph~$G$, we also denote by~$V(G)$ and~$E(G)$ the vertex and edge set of~$G$, respectively.
We denote an edge $e \in E$ between vertices $u,v \in V$ as a set $e=\{u,v\}$.
For the sake of simplicity of the representation, an edge $e$ is sometimes also denoted by $uv$. 
A path~$P$ in $G$ is a subgraph of $G$ with vertex set~$V(P)=\{v_1,\dots,v_k\}$ and edge set~$E(P)=\{\{v_i,v_{i+1}\} :  1\leq i<k\}$
(we often represent path~$P$ by the tuple~$(v_1,v_2,\dots,v_k)$).

Let $v_1,v_2,\ldots,v_n$ be the $n$ vertices of the graph $G$. 
For simplicity of the presentation (and with a slight abuse of notation) we refer during the paper to the entry $D_{i,j}$ of the matrix $D$ as $D_{a,b}$, where $a=v_i$ and $b=v_j$. 
That is, we put as indices of the matrix $D$ the corresponding vertices of $G$ whenever it is clear from the context. 


Let $P=(u=v_1, v_2, \dots, v_p=v)$ be a path from $u$ to $v$ in $G$. 
Recall that, in our paper, every edge has exactly one time label in every period of $\Delta$ consecutive time steps. 
Therefore, as we are only interested in the fastest duration of temporal paths, 
many times we refer to $(P,\lambda,\Delta)$ as any of the temporal paths from $u=v_1$ to $v=v_p$ along the edges of $P$, which starts at the edge $v_1 v_2$ at time $\lambda(v_1 v_2) + c \Delta$, for some $c\in \mathbb{N}$, and then sequentially visits the rest of the edges of $P$ as early as possible. 
We denote by $d(P,\lambda,\Delta)$, or simply by $d(P,\lambda)$ when $\Delta$ is clear from the context, the duration of any of the temporal paths $(P,\lambda,\Delta)$; note that they all have the same duration. 
Many times we also refer to a path $P=(u=v_1, v_2, \dots, v_p=v)$ from $u$ to $v$ in $G$,
as a temporal path in $(G,\lambda,\Delta)$,
where we actually mean that $(P,\lambda,\Delta)$ is a temporal path with $P$ as its underlying (static) path.


We remark that a fastest path between two vertices in a temporal graph can be computed in polynomial time~\cite{xuan_computing_2003,Wu2016Efficient}.
%Wu et~al.~\cite{Wu2016Efficient} provide an algorithm that computes the duration of the fastest temporal path from a source vertex $v$, in a temporal graph $(G,\lambda)$, to all other vertices,
%that runs in polynomial-time.
Hence, given a $\Delta$-periodic temporal graph $(G,\lambda,\Delta)$, we can compute in polynomial-time  the matrix $D$
which consists of durations of fastest temporal paths among all pairs of vertices in $(G,\lambda,\Delta)$.

\begin{comment}
Let $(G,\lambda)$ be a temporal graph with  $n = |V(G)|$ and  $m=|E(G)|$.
Let $v \in V(G)$ be an arbitrary vertex of $G$, denote with $deg_{max}$ the maximum degree of all vertices in $V(G)$ and let $S_v$ be the set of time edges in $(G,\lambda)$, incident to $v$, \ie $S_v = \{(uv, \lambda(uv)) | uv \in E(G)\}$.
In their work Wu et~al.~\cite{Wu2016Efficient} provide an algorithm that computes the duration of the fastest temporal path from a source vertex $v$ to all other vertices in $G$ in
$O(n + m \log c)$ time, where $c = \min \{|S_v|, deg_{max}\}$.
From this result, we can deduce the following. 
\begin{lemma} \label{lemma:calculatingD}
Let $(G, \lambda, \Delta)$ be a $\Delta$-periodic temporal graph, where $\lambda$ assigns exactly $k$ labels to every edge of $G$. 
Denote with $deg_{max}$ the maximum degree of vertices in $G$, let $deg(v_i)$ be the degree of vertex $v_i \in V(G)$,
and let $c_{v_i} = \min \{ k \cdot deg(v_i), deg_{max}\}$.\\
To calculate the durations of all fastest temporal paths from a fixed vertex $v \in V(G)$ to all other vertices, it takes $O(n + m \log c_v)$ time. \\
To calculate the durations of the fastest temporal paths among all pairs of vertices we then need $O(n^2 + m \sum_{v \in V(G)} \log c_v)$ time.
\end{lemma}

Observe that $O(n + m \log c_v) = O(n + m \log deg_{max}) = O(n + m \log n) = O(n^2 \log n)$ and similarly
$O(n^2 + m \sum_{v \in V(G)} \log c_v) = O(n^2 + mn \log deg_{max}) = O(n + mn \log n) = O(n^3 \log n)$.
Since an instance $I$ of \kDeltaExact\ problem is an $n \times n$ matrix $D$, the running time of calculating one row of $D$ (\ie the fastest temporal paths from a single vertex to all others) takes $O(|I|\log \sqrt{|I|})$-time and calculating the whole matrix $D$ (\ie the fastest temporal paths among all pairs of vertices) takes $O(|I|^{3/2} \log \sqrt{|I|})$ time.
Therefore, from now on we say that calculating (a row of) $D$ takes polynomial time.
\end{comment}
%\section{Results}



\section{Hardness results for \deltaExact}  
In this section we present our main computational hardness results.  
We first show that \deltaExact\ is NP-hard even for constant $\Delta$. 
%Then we investigate the parameterized computational hardness of \deltaExact\ with respect to structural parameters of the underlying graph. We show that \deltaExact\ is W[1]-hard when parameterized by the feedback vertex number of the underlying graph.

%\subparagraph{NP-hardness of \deltaExact.}\label{sec:nphardness}
%We prove that in general it is NP-hard to determine a $\Delta$-periodic temporal graph $(G,\lambda)$ respecting a duration matrix $D$,
%even if $\Delta$ is a small constant.

\begin{theorem}[$\star$]\label{thm:NPhardness}
	\deltaExact\ is \NP-hard for all $\Delta \geq 3$.
\end{theorem}

\begin{comment}

\begin{proof}
	We present a polynomial-time reduction from the NP-hard problem NAE 3-SAT~\cite{Schaefer1978complexity}. Here we are given a formula $\phi$ that is a conjunction of so-called NAE (not-all-equal) clauses, where each clause contains exactly 3 literals (with three distinct variables).
    A NAE clause evaluates to \textsc{true} if and only if not all of its literals are equal, that is, at least one literal evaluates to \textsc{true} and at least one literal evaluates to \textsc{false}.
    We are asked whether $\phi$ admits a satisfying assignment. 

    
    Given an instance $\phi$ of NAE 3-SAT, we construct an instance $(D,\Delta)$ of \deltaExact\ as follows.

 We start by describing the vertex set of the underlying graph $G$ of $D$.
\begin{itemize}
\item For each variable $x_i$ in $\phi$, we create three variable vertices $x_i, x_i^T, x_i^F$.
\item For each clause $c$ in $\phi$, we create one clause vertex $c$.
\item We add one additional super vertex $v$.
\end{itemize}
Next, we describe the edge set of $G$.
\begin{itemize}
\item For each variable $x_i$ in $\phi$ we add the following five edges: 
$x_i x_i^T, x_i x_i^F, x_i^T x_i^F, x_i^T v$ and $ x_i^Fv$.
\item For each pair of variables $x_i,x_j$ in $\phi$ with $i \neq j$ we add the following four edges: 
$x_i^T x_j^T, x_i^Tx_j^F, x_i^Fx_j^T$ and $x_i^Fx_j^F$.
\item For each clause $c$ in $\phi$ we add one edge for each literal. Let $x_i$ appear in $c$. If $x_i$ appears non-negated in $c$ we add edge $c x_i^T$. 
If $x_i$ appears negated in $c$ we add edge $c x_i^F$.
\end{itemize}
This finishes the construction of $G$.
For an illustration see~\cref{fig:NP-example}.

%
\begin{figure}[htb]
	\noindent
	\makebox[\textwidth]{
		\centering
\begin{tikzpicture}%[xscale=2]

	%%Variable X1
	\node (x1t) at (1,0) {};
	\node (x1f) at (3,0) {};
	
	%%Variable X2
	\node (x2t) at (5,0) {};
	\node (x2f) at (7,0) {};
	
	%%Variable x3
	\node (x3t) at (9,0) {};
	\node (x3f) at (11,0) {};
	
	%%Variable x4
	\node (x4t) at (13,0) {};
	\node (x4f) at (15,0) {};

	%% edges among xt, xf vertices
	%x1 to all
	\draw [dotted,gray] (x1t) [out=30,in=150] to (x2t);
	\draw [dotted,gray] (x1t) [out=30,in=150] to (x3t);
	\draw [dotted,gray] (x1t) [out=30,in=150] to (x4t);
	\draw [dotted,gray] (x1t) [out=30,in=150] to (x2f);
	\draw [dotted,gray] (x1t) [out=30,in=150] to (x3f);
	\draw [dotted,gray] (x1t) [out=30,in=150] to (x4f);
	
	\draw [dotted,gray] (x1f) [out=30,in=150] to (x2t);
	\draw [dotted,gray] (x1f) [out=30,in=150] to (x3t);
	\draw [dotted,gray] (x1f) [out=30,in=150] to (x4t);
	\draw [dotted,gray] (x1f) [out=30,in=150] to (x2f);
	\draw [dotted,gray] (x1f) [out=30,in=150] to (x3f);
	\draw [dotted,gray] (x1f) [out=30,in=150] to (x4f);
	%x2 to all
	\draw [dotted,gray] (x2t) [out=30,in=150] to (x3t);
	\draw [dotted,gray] (x2t) [out=30,in=150] to (x4t);
	\draw [dotted,gray] (x2t) [out=30,in=150] to (x3f);
	\draw [dotted,gray] (x2t) [out=30,in=150] to (x4f);
	
	\draw [dotted,gray] (x2f) [out=30,in=150] to (x3t);
	\draw [dotted,gray] (x2f) [out=30,in=150] to (x4t);
	\draw [dotted,gray] (x2f) [out=30,in=150] to (x3f);
	\draw [dotted,gray] (x2f) [out=30,in=150] to (x4f);
	%x3 to all
	\draw [dotted,gray] (x3t) [out=30,in=150] to (x4t);
	\draw [dotted,gray] (x3t) [out=30,in=150] to (x4f);
	
	\draw [dotted,gray] (x3f) [out=30,in=150] to (x4t);
	\draw [dotted,gray] (x3f) [out=30,in=150] to (x4f);

	%%Variable X1
	\node[vert,label=left:$x_1^T$] (x1t) at (1,0) {};
	\node[vert,label={[fill=white]right:$x_1^F$}] (x1f) at (3,0) {};
	\node[vert,label=above:$x_1$] (x1) at (2,1) {};
	\draw (x1t) -- (x1f) -- (x1) -- (x1t);
	
	%%Variable X2
	\node[vert,label={[fill=white]left:$x_2^T$}] (x2t) at (5,0) {};
	\node[vert,label={[fill=white]right:$x_2^F$}] (x2f) at (7,0) {};
	\node[vert,label={[fill=white]above:$x_2$}] (x2) at (6,1) {};
	\draw (x2t) -- (x2f) -- (x2) -- (x2t);
	
	%%Variable x3
	\node[vert,label={[fill=white]left:$x_3^T$}] (x3t) at (9,0) {};
	\node[vert,label={[fill=white]right:$x_3^F$}] (x3f) at (11,0) {};
	\node[vert,label={[fill=white]above:$x_3$}] (x3) at (10,1) {};
	\draw (x3t) -- (x3f) -- (x3) -- (x3t);
	
	%%Variable x4
	\node[vert,label={[fill=white]left:$x_4^T$}] (x4t) at (13,0) {};
	\node[vert,label=right:$x_4^F$] (x4f) at (15,0) {};
	\node[vert,label=above:$x_4$] (x4) at (14,1) {};
	\draw (x4t) -- (x4f) -- (x4) -- (x4t);
	
	%%vertices for clauses c1, c2 + vertex v
	\node[vert,label=above:$v$] (v) at (8,3) {};
	\node[vert,label=below:$c_1$] (c1) at (4.5,-3) {};
	\node[vert,label=below:$c_2$] (c2) at (11.5,-3) {};
	
	%%% edges between x1 gadget and v,c1,c2
	\draw (x1t) to node[timelabel] {$1$} (c1);
	\draw (x1t) to node[timelabel] {$1$} (c2);
	\draw (x1t) to [out=90,in=190] (v);
	\draw (x1f) to [out=90,in=200] node[timelabel] {$3$} (v);
	
	%%% edges between x2 gadget and v,c1,c2
	\draw (x2f) to node[timelabel] {$1$} (c1);
	\draw (x2t) to node[timelabel] {$1$} (c2);
	\draw (x2t) to [out=80,in=210]  (v);
	\draw (x2f) to node[timelabel] {$3$} (v);
	
	%%% edges between x3 gadget and v,c1
	\draw (x3t) to node[timelabel] {$1$} (c1);
	\draw (x3t) to node[timelabel] {$3$} (v);
	\draw (x3f) to [out=100,in=330] (v);
	
	%%% edges between x4 gadget and v,c2
	\draw (x4t) to node[timelabel] {$1$} (c2);
	\draw (x4t) to [out=90,in=340] node[timelabel] {$3$} (v);
	\draw (x4f) to [out=90,in=360] (v);
	

\end{tikzpicture}
}
\caption{Illustration of the temporal graph $(G,\lambda)$ from the NP-hardness reduction, 
	where the NAE 3-SAT formula $\phi$ is of the form $\phi = \text{NAE}(x_1, \overline{x}_2, x_3) \wedge \text{NAE}(\overline{x}_1, x_2, x_4)$.
To improve the readability, we draw edges between vertices $x_i^T$ and $x_j^F$ (where $i \neq j$) with gray dotted lines.
Presented is the labeling of $G$ corresponding to the assignment $x_1=x_2=\textsc{true}$ and $x_3,x_4=\textsc{false}$,
where all unlabeled edges get the label $2$.
}\label{fig:NP-example}
\end{figure}
%
We set $\Delta$ to some constant larger than two, that is, $\Delta\ge 3$. Next, we specify the durations in the matrix $D$ between all vertex pairs.
For the sake of simplicity we write $D_{u,v}$ as $d(u,v)$,
where $u,v$ are two vertices of $G$. 
We start by setting the value of $d(u,v) = 1$ where $u$ and $v$ are two adjacent vertices in $G$.
\begin{itemize}
    %\item For each variable $x$ in $\phi$ we specify the following distances between the non-adjacent variable vertices:
    %$d(x_1,x_2)=2$. 
    %\item For pair of variable $x,y$ in $\phi$ with $x\neq y$ we specify the following 
    %$d(x_1,y^T)=d(x_1,y^F)=3$, $d(x_2,y^T)=d(x_2,y^F)=2$.
    \item For each variable $x_i$ in $\phi$ and the super vertex $v$
    we specify the following durations:
    $d(x_i,v)=2$ and $d(v,x_i)= \Delta $. %, $d(x_2,v)=3$.
    \item For each clause $c$ in $\phi$ and the super vertex $v$
    we specify the following durations:
    $d(c,v)=2$ and $d(v,c)= \Delta - 1$.
    \item Let $x_i$ be a variable that appears in clause $c$, then  we specify the following durations:
    $d(c,x_i)=2$ and $d(x_i,c)=\Delta$.
    If $x_i$ appears non-negated in $c$ we specify the following durations:
    $d(c,x_i^F)=2$ and $d(x_i^F,c)=\Delta$.
    If $x_i$ appears negated in $c$ we specify the following duratios:
    $d(c,x_i^T)=2$ and $d(x_i^T,c)=\Delta$.
    \item Let $x_i$ be a variable that does \emph{not} appear in clause $c$, then we specify the following duratios:
    $d(x_i,c)=\Delta$, $d(c,x_i)=2\Delta + 2$
    and
    $d(c,x_i^T)=d(c,x_i^F)=2$, $d(x_i^T,c)=d(x_i^F,c)=\Delta$. 
    \item For each pair of variables $x_i \neq x_j$ in $\phi$ we specify the following duratios:
    $d(x_i,x_j)=2\Delta +1$ and
    $d(x_i,x_j^T)=d(x_i,x_j^F)=\Delta + 1$.
    \item For each pair of clauses $c_i \neq c_j$ in $\phi$ we specify the following duratios:
    $d(c_i,c_j)= \Delta + 1$.
\end{itemize}
This finishes the construction of the instance $(D,\Delta)$ of \deltaExact\, which can clearly be done in polynomial time. We defer the correctness proof to the appendix.
\end{proof}
    
\end{comment}


%\subparagraph{Parameterized Hardness of \deltaExact.}\label{sec:w1hardness}

Next, we investigate the parameterized hardness of \deltaExact\ with respect to structural parameters of the underlying graph. We show that the problem is W[1]-hard when parameterized by the feedback vertex number of the underlying graph. 
The \emph{feedback vertex number} of a graph $G$ is the cardinality of a minimum vertex set $X\subseteq V(G)$ such that $G-X$ is a forest. The set $X$ is called a \emph{feedback vertex set}. 
Note that, in contrast to the previous result (\cref{thm:NPhardness}), the reduction we use to obtain the following result does not produce instances with a constant $\Delta$.

\begin{theorem}[$\star$]\label{thm:W1wrtFVS}
    \deltaExact\ is W[1]-hard when parameterized by the feedback vertex number of the underlying graph.
\end{theorem}
\begin{proof}
    We present a parameterized reduction from the W[1]-hard problem \textsc{Multicolored Clique} parameterized by the number of colors~\cite{fellows2009multipleinterval}.  Here, given a $k$-partite graph $H=(W_1\uplus W_2 \uplus\ldots\uplus W_k, F)$, we are asked whether $H$ contains a clique of size $k$. If $w\in W_i$, then we say that $w$ has \emph{color} $i$. W.l.o.g.\ we assume that $|W_1|=|W_2|=\ldots=|W_k|=n$. 
    Furthermore, for all $i\in[k]$, we assume the vertices in $W_i$ are ordered in some arbitrary but fixed way, that is, $W_i=\{w^i_1,w^i_2,\ldots,w^i_n\}$.
    Let $F_{i,j}$ with $i<j$ denote the set of all edges between vertices from $W_i$ and $W_j$. We assume w.l.o.g.\ that $|F_{i,j}|=m$ for all $i< j$ (if not we can add $k \max_{i,j}|F_{i,j}|$ vertices to each $W_i$ and use those to add up to $\max_{i,j}|F_{i,j}|$ additional isolated edges to each $F_{i,j}$).
    Furthermore, for all $i<j$ we assume that the edges in $F_{i,j}$ are ordered in some arbitrary but fixed way, that is, $F_{i,j}=\{e^{i,j}_1,e^{i,j}_2,\ldots,e^{i,j}_m\}$.

We give a reduction to a variant of \deltaExact\ where the period $\Delta$ is infinite (that is, the sought temporal graph is not periodic and the labeling function $\lambda : E\rightarrow \mathbb{N}$ maps to the natural numbers) and we allow $D$ to have infinity entries, meaning that the two respective vertices are not temporally connected. 
Note that, given the matrix $D$, we can easily compute the underlying graph $G$, as follows. Two vertices $v,v'$ are adjacent in $G$ if and only if $D_{v,v'}=1$, as having an edge between $v$ and $v'$ is the only way that there exists a temporal path from $v$ to $v'$ with duration 1. 
For simplicity of the presentation of the reduction, we describe the underlying graph $G$ (which directly implies the entries of $D$ where $D_{v,v'}=1$) and then we provide the remaining entries of $D$. 
In the full paper \cite{fullPaper}, we show how to obtain the result for a finite $\Delta$ (by introducing a so-called ``infinity gadget'') and a matrix $D$ of durations of fastest paths which only has finite entries. 

\begin{figure}%[t]
\noindent\makebox[\textwidth]{
\centering
\includegraphics{fig-W1-reduction}
    }
    \caption{Illustration of part of the underlying graph $G$ and a possible labeling. Edges incident with vertices $\hat{v}_1,\hat{v}_2$ of connector gadgets are omitted. Gray vertices form a feedback vertex set.
    The double line connections, between a vertex $v_{i-1}^j$ in the verification gadget, and $u_1^3$ in the edge selection gadget, 
    and, between a vertex $u_2^3$ in the edge selection gadget, and $v_{i}^j$ in the verification gadget,
    consist of $5n$ vertices $a_1^{j,i,3},a_2^{j,i,3},\dots,a_{5n}^{j,i,3}$ 
    and $b_1^{j,i,3},b_2^{j,i,3},\dots,b_{5n}^{j,i,3}$, respectively.
    }\label{fig:hardness1}
\end{figure}


In the following, we give an informal description of the main ideas of the reduction. The construction uses several gadgets, where the main ones are an ``edge selection gadget'' and a ``verification gadget''.


Every \emph{edge selection gadget} is associated with a color combination $i,j$ in the \textsc{Multicolored Clique} instance, and its main purpose is to ``select'' an edge connecting a vertex from color $i$ with a vertex from color $j$.
Roughly speaking, the edge selection gadget consists of $m$ paths, one for every edge in $F_{i,j}$ (see \cref{fig:hardness1} for reference). The distance matrix $D$ will enforce that the labels on those paths effectively order them temporally, that is, in particular, the labels on one of the paths will be smaller than the labels on all other paths. The edge corresponding to this path is selected.


 We have a \emph{verification gadget} for every color $i$. They interact with the edge selection gadgets as follows.
 The verification gadget for color $i$ is connected to all edge selection gadgets that involve color $i$. More specifically, this is connected to every path corresponding to an edge at a position in the path that encodes the endpoint of color $i$ of that edge (again, see \cref{fig:hardness1} for reference). Intuitively, the distances in the verification gadget are only realizable if the selected edges all have the same endpoint of color $i$.
Hence, the distances of all verification gadgets can be realized if and only if the selected edges form a clique. 

Furthermore, we use an \emph{alignment gadget} which, intuitively, ensures that the labelings of all gadgets use the same range of time labels. Finally, we use \emph{connector gadgets} which create shortcuts between all vertex pairs that are irrelevant for the functionality of the other gadgets. This allows us to easily fill in the distance matrix with the corresponding values.
We ensure that all our gadgets have a constant feedback vertex number, hence the overall feedback vertex number is quadratic in the number of colors of the \textsc{Multicolored Clique} instance and we get the parameterized hardness result.

In the following, for every gadget, we give a formal description of the underlying graph of this gadget (\ie not the complete distance sub-matrix of the gadget). Due to space constraints, we defer the description of the distance matrix $D$ and the formal proof of correctness for the reduction to the full paper~\cite{fullPaper}.

    Given an instance $H$ of \textsc{Multicolored Clique}, we construct an instance $D$ of \deltaExact\ (with infinity entries and no periods) as follows. 
    %To ease the presentation, we first describe the underlying graph $G$ that is implicitly defined by the entries $D_{v,v'}=1$, that is, the pairs of vertices $v,v'$ that should be connected by a temporal path of duration one, meaning that there needs to be an edge connecting the two vertices. Afterwards, we describe the remaining entries of $D$.
    %We will construct $G$ using several gadgets. 
    
    \emph{Edge selection gadget.} We first introduce an \emph{edge selection gadget $G_{i,j}$ for color combination $i,j$} with $i<j$. We start with describing the vertex set of the gadget.
    \begin{itemize}
        \item A set $X_{i,j}$ of vertices $x_1, x_2, \ldots, x_m$.
        %\item A set $Y_{i,j}$ of vertices $y_1, y_2, \ldots, y_m$.
        %\item A set $Z_{i,j}$ of vertices $z_1, z_2, \ldots, z_m$.
        \item Vertex sets $U_1, U_2, \ldots, U_m$ with $4n+1$ vertices each, that is, $U_\ell=\{u^\ell_0, u^\ell_1, u^\ell_2,\ldots, 
        %u^\ell_n, u^\ell_{n+1},\ldots, u^\ell_{4n-1}, 
        u^\ell_{4n}\}$ for all $\ell\in[m]$. 
        %Let $U_{i,j}=\bigcup_{\ell\in[n]} U_\ell$.
        \item Two special vertices $v_{i,j}^\star,v_{i,j}^{\star\star}$.
    \end{itemize}
    The gadget has the following edges.
    \begin{itemize}
        \item For all $\ell\in [m]$ we have edge $\{x_\ell,v_{i,j}^\star\}$, $\{v_{i,j}^\star,u^\ell_0\}$, and $\{u^\ell_{4n},v_{i,j}^{\star\star}\}$. 

        %Furthermore, we have edges $\{y_\ell,u^\ell_1\}$ and $\{z_\ell,u^\ell_{2n}\}$.
        \item For all $\ell\in [m]$ and $\ell'\in [4n]$, we have edge $\{u^\ell_{\ell'-1},u^\ell_{\ell'}\}$.
    \end{itemize}
    %This finishes the construction of the edge selection gadget.

    
    \emph{Verification gadget.} For each color $i$, we introduce the following vertices. What we describe in the following will be used as a \emph{verification gadget for color $i$}.
    \begin{itemize}
        \item We have one vertex $y^i$ and $k+1$ vertices $v^i_\ell$ for $0\le \ell\le k$.
        \item For every $\ell\in[m]$ and every $j\in[k]\setminus\{i\}$ we have $5n$ vertices $a^{i,j,\ell}_1,a^{i,j,\ell}_2,\ldots,a^{i,j,\ell}_{5n}$ and $5n$ vertices $b^{i,j,\ell}_1,b^{i,j,\ell}_2,\ldots,b^{i,j,\ell}_{5n}$.
        \item We have a set $\hat{U}_i$ of $13n+1$ vertices $\hat{u}^i_1,\hat{u}^i_2,\ldots,\hat{u}^i_{13n+1}$.
    \end{itemize}
    We add the following edges. We add edge $\{y^i,v^i_0\}$.
    %For every $j\in[k]\setminus\{i,i+1\}$ and every $\ell\in[m]$ we add edge $\{v^i_{j-1},\hat{u}^{i,j,\ell}_1\}$. For every $\ell\in[m]$ we add edge $\{\hat{u}^i_{n+3},\hat{u}^{i,i+1,\ell}_1\}$.
    For every $\ell\in[m]$, every $j\in[k]\setminus\{i\}$, and every $\ell'\in[5n-1]$ we add edge $\{a^{i,j,\ell}_{\ell'},a^{i,j,\ell}_{\ell'+1}\}$ and we add edge $\{b^{i,j,\ell}_{\ell'},b^{i,j,\ell}_{\ell'+1}\}$.
    %Assume $1\neq i \neq k$. We describe the two cases $i=1$ and $i=k$ afterwards. 
    %If $i\neq 1$, let $e_\ell\in F_{1,i}$ let $w^i_{\ell'}\in W_i$ be incident with $e_\ell$. Then we add edge $\{v^i_0,u^\ell_{\ell'}\}$ between $v^i_0$ and the vertex $u^\ell_{\ell'}$ of the edge selection gadget of color combination $1,i$. 
    
    Let $1\le j<i$ (skip if $i=1$), let $e_\ell^{j,i}\in F_{j,i}$, and let $w^i_{\ell'}\in W_i$ be incident with $e_\ell^{j,i}$. Then we add edge $\{v_{j-1}^i,a^{i,j,\ell}_{1}\}$ and we add edge $\{a^{i,j,\ell}_{5n},u^\ell_{\ell'-1}\}$ between $a^{i,j,\ell}_{5n}$ and the vertex $u^\ell_{\ell'-1}$ of the edge selection gadget of color combination $j,i$.
    Furthermore, we add edge $\{v_{j}^i,b^{i,j,\ell}_{1}\}$ and edge $\{b^{i,j,\ell}_{5n},u^\ell_{\ell'}\}$ between $b^{i,j,\ell}_{5n}$ and the vertex $u^\ell_{\ell'}$ of the edge selection gadget of color combination $j,i$.

    We add edge $\{v^i_{i-1},\hat{u}^i_1\}$ and for all $\ell''\in[13n]$ we add edge $\{\hat{u}^i_{\ell''},\hat{u}^i_{\ell''+1}\}$. Furthermore, we add edge $\{\hat{u}^i_{13n+1},v^i_i\}$. 
    %Let $e_\ell^{i,i+1}\in F_{i,i+1}$ and let $w^i_{\ell'}\in W_i$ be incident with $e_\ell^{i,i+1}$. If $i\neq 1\neq k$, then we add edge $\{\hat{u}^i_{n+3},a^{i,i+1,\ell}_{1}\}$ and edge $\{a^{i,i+1,\ell}_{5n},u^\ell_{n+\ell'-1}\}$ between $a^{i,i+1,\ell}_{5n}$ and the vertex $u^\ell_{n+\ell'-1}$ of the edge selection gadget of color combination $i,i+1$. If $i=1$, then we add edge $\{v^i_0,a^{i,i+1,\ell}_{1}\}$ and edge $\{a^{i,i+1,\ell}_{5n},u^\ell_{n+\ell'-1}\}$ between $a^{i,i+1,\ell}_{5n}$ and the vertex $u^\ell_{n+\ell'-1}$ of the edge selection gadget of color combination $i,i+1$.
%Furthermore, we add edge $\{v_{i+1}^i,b^{i,i+1,\ell}_{1}\}$ and edge $\{b^{i,i+1,\ell}_{5n},u^\ell_{\ell'}\}$ between $b^{i,i+1,\ell}_{5n}$ and the vertex $u^\ell_{\ell'}$ of the edge selection gadget of color combination $i,i+1$.

    Let $i<j\le k$ (skip if $i=k$), let $e_\ell^{i,j}\in F_{i,j}$, and let $w^i_{\ell'}\in W_i$ be incident with $e_\ell^{i,j}$. Then we add edge $\{v_{j-1}^i,a^{i,j,\ell}_{1}\}$ and edge $\{a^{i,j,\ell}_{5n},u^\ell_{3n+\ell'-1}\}$ between $a^{i,j,\ell}_{5n}$ and the vertex $u^\ell_{3n+\ell'-1}$ of the edge selection gadget of color combination $i,j$.
    Furthermore, we add edge $\{v_{j}^i,b^{i,j,\ell}_{1}\}$ and edge $\{b^{i,j,\ell}_{5n},u^\ell_{3n+\ell'}\}$ between $b^{i,j,\ell}_{5n}$ and the vertex $u^\ell_{3n+\ell'}$ of the edge selection gadget of color combination $i,j$.




Furthermore, we use \emph{connector gadgets}, two for each edge selection gadget, and two for every verification gadget. They consist of six vertices $\hat{v}_0,\hat{v}_0',\hat{v}_1,\hat{v}_2,\hat{v}_3,\hat{v}_3'$ and, intuitively, are used to connect many vertex pairs by fast paths, which will make arguing about possible labelings in \textsc{Yes}-instances much easier. Finally, we have an \emph{alignment gadget}, which is a star with a center vertex $w^\star$ and a leaf for every other gadget. Intuitively, this gadget is used to relate labels of different gadgets to each other. A formal description of these two gadgets is given in the full paper~\cite{fullPaper}.

This finishes the description of the underlying graph $G$. For an illustration see \cref{fig:hardness1}. We can observe that the vertex set containing
%\begin{itemize}
 %   \item 
    vertices $v_{i,j}^\star$ and $v_{i,j}^{\star\star}$ of each edge selection gadget,
    %\item 
    vertices $v^i_\ell$ with $0\le \ell\le k$ of each verification gadget,
    %\item 
    vertices $\hat{v}_1$ and $\hat{v}_2$ of each connector gadget, and
    %\item 
    vertex $w^\star$ of the alignment gadget
%\end{itemize}
forms a feedback vertex set in $G$ with size $O(k^2)$.

As mentioned before, due to space constraints, we defer the description of the distance matrix $D$ and a formal correctness proof of the reduction to the full paper~\cite{fullPaper}.
\end{proof}


%\pagebreak

\section{Algorithms for \deltaExact}
%%%%%
%%%%% CHANGES BELOW - NKL
In this section, to complement the discussed hardness aspects of \deltaExact, we present some algorithmic results.
We start by restricting the underlying graph $G$ of the input matrix~$D$ of \deltaExact\ to be a tree and get the following.
\begin{theorem}[$\star$] \label{thm:deltaExact-PolyTimeTrees}
    \deltaExact\ can be solved in polynomial time on trees.
\end{theorem}
The main reason, for which \deltaExact\ is straightforward to solve on trees, is twofold: 
\begin{itemize}
    \item between any pair of vertices $v_i$ and $v_j$ in the tree $T$, there is a \emph{unique} path $P$ in $T$ from $v_i$ to $v_j$, and 
    \item in any periodic temporal graph $(T,\lambda,\Delta)$ and any fastest temporal path $P=((e_1,t_1),\ldots,(e_i,t_i),\ldots,(e_j,t_j),\ldots,(e_{\ell-1},t_{\ell-1}))$ from $v_1$ to $v_{\ell}$ we have that the sub-path $P'=((e_i,t_i),\ldots,(e_{j-1},t_{j-1}))$ is also a fastest temporal path from $v_i$ to $v_j$.
\end{itemize}
However, these two nice properties do not hold when the underlying graph is not a tree. For example, in~\cref{fig:ftpExample}, the fastest temporal path from $u$ to $v$ is $P_{u,v}$ (depicted in blue) goes through~$w$, however the sub-path of $P_{u,v}$ that stops at $w$ is not the fastest temporal path from $u$ to $w$. The fastest temporal path from $u$ to $w$ consists only of the single edge $uw$ (with label $9$ and duration $1$, depicted in red).
%, while the fastest temporal path from $u$ to $v$ contains the four other edges (with labels 1, 3, 5, 7 and duration 7). 

Nevertheless, we prove that we can still solve \deltaExact\ efficiently if the underlying graph is similar to a tree; more specifically we show the following result, which turns out to be non-trivial.


%%%%%%%
%%%%%%% CHANGES ABOVE - NKL
\begin{comment}
In this section we provide several algorithms for \deltaExact. By \cref{thm:NPhardness} we have that \deltaExact\ is NP-hard in general, hence we start by identifying restricted cases where we can solve the problem in polynomial time.
We first show in \cref{sec:treealgo} that if the underlying graph $G$ of an instance $(D, \Delta)$ of \deltaExact\ is a tree, then we can determine desired $\Delta$-periodic labeling $\lambda$ of $G$ in polynomial time. In \cref{sec:FPT} we generalize this result. We show that \deltaExact\ is fixed-parameter tractable when parameterized by the feedback edge number of the underlying graph. Note that our parameterized hardness result (\cref{thm:W1wrtFVS}) implies that we presumably cannot replace the feedback edge number with the smaller parameter feedback vertex number, or any other parameter that is smaller than the feedback vertex number, such as e.g.\ the treewidth.



\subsection{Polynomial-time algorithm for trees}\label{sec:treealgo}
%All of the above is used in the design of the following polynomial-time algorithms.
We now provide a polynomial-time algorithm for \deltaExact\ when the underlying graph is a tree.
Let $D$ be the input matrix and let the underlying graph $G$ of $D$ be a tree on $n$ vertices $\{v_1, v_2, \dots, v_n\}$.
Let $v_i,v_j$ be two arbitrary vertices in $G$, then we know that there exists a unique (static) path $P_{i,j}$ from $v_i$ to $v_j$. We will heavily exploit this in our algorithm.
%Consequently, the temporal path $(P_{i,j},\lambda)$ from $v_i$ to $v_j$ is also unique, up to modulo of the period $\Delta$ of the labeling $\lambda$,
%and therefore are the fastest.
%Then $D$ is of the following form:
%\begin{equation*}
%    D_{i,j} =
%    \begin{cases}
%    0 & \text{if $i = j$}, \\
%    1 & \text{if $v_i$ and $v_j$ are neighbours in G}\\
%    d(P_{i,j},\lambda) & \text{else}
%    \end{cases},
%\end{equation*}
%where $d(P_{i,j},\lambda)$ is the duration of the (unique) temporal path $(P_{i,j},\lambda)$ from $v_i$ to $v_j$.

%\begin{observation}\label{obs:travel-delays-in-trees}
%    Let $v_i,v_j$  be arbitrary two vertices in a tree $G$. 
%    Since there is a unique temporal path $(P_{i,j},\lambda)$ from $v_i$ to $v_j$, it is also the fastest one, therefore $d(P_{i,j},\lambda) = D_{i,j}$. 
%    Note, all other vertices $v' \in P_{i,j} \setminus \{v_i,v_j\}$ are reached form $v_i$ using a part of the path $(P_{i,j},\lambda)$.
%    \end{observation}
%    Now using \cref{lemma:unique-fastest-path-allDelays}, we can determine the waiting times for all \emph{inner} vertices of $P_{i,j}$.


\begin{theorem}[$\star$] \label{thm:deltaExact-PolyTimeTrees}
    \deltaExact\ can be solved in polynomial time on trees.
\end{theorem}








\subsection{FPT-algorithm for feedback edge number}\label{sec:FPT}

Recall from \cref{sec:treealgo} that the main reason, for which \deltaExact\ is straightforward to solve on trees, is twofold: 
\begin{itemize}
    \item between any pair of vertices $v_i$ and $v_j$ in the tree $T$, there is a \emph{unique} path $P$ in $T$ from $v_i$ to $v_j$, and 
    \item in any periodic temporal graph $(T,\lambda,\Delta)$ and any fastest temporal path $P=((e_1,t_1),\ldots,(e_i,t_i),\ldots,(e_j,t_j),\ldots,(e_{\ell-1},t_{\ell-1}))$ from $v_1$ to $v_{\ell}$ we have that the sub-path $P'=((e_i,t_i),\ldots,(e_{j-1},t_{j-1}))$ is also a fastest temporal path from $v_i$ to $v_j$.
\end{itemize}
However, these two nice properties do not hold when the underlying graph is not a tree. For example, in~\cref{fig:ftpExample}, the fastest temporal path from $u$ to $v$ is $P_{u,v}$ (depicted in blue) goes through~$w$, however the sub-path of $P_{u,v}$ that stops at $w$ is not the fastest temporal path from $u$ to $w$. The fastest temporal path from $u$ to $w$ consists only of the single edge $uw$ (with label $9$ and duration $1$, depicted in red).
%, while the fastest temporal path from $u$ to $v$ contains the four other edges (with labels 1, 3, 5, 7 and duration 7). 

Nevertheless, we prove in this section that we can still solve \deltaExact\ efficiently if the underlying graph is similar to a tree; more specifically we show the following result, which turns out to be non-trivial.
\end{comment}
	\begin{figure}[t]
    \centering
	\begin{tikzpicture}[xscale=2.2,yscale=0.5]
	%%%S_uv
	\node[vert,label=below:$u$] (v1) at (1,0) {};
	\node[vert] (v2) at (2,0) {};
	\node[vert,label=below:$w$] (v3) at (3,0) {};
	\node[vert] (v4) at (4,0) {};
	\node[vert,label=below:$v$] (v5) at (5,0) {};

	\draw[transform canvas={yshift=-1.5mm}, blue]
	(v1) edge[diredge2]  node[pos=0.3,yshift=-2,label=below:$P_{u,v}$] {} (v5) ;
	
	\draw[red]
	(v1) edge[diredge2] [out=85,in=95,distance=2.1cm] node[pos=0.3,yshift=2,label=above:$P_{u,w}$] {} (v3) ;
 
	\draw (v1) -- node[label=above:$1$] {} (v2) -- node[label=above:$3$] {}  (v3) -- node[label=above:$5$] {} (v4) -- node[label=above:$7$] {} (v5);
	\draw (v1) to [out=80,in=100,distance=2cm] node[label=above:$9$] {} (v3);
	

\end{tikzpicture}
	\caption{An example of a temporal graph (with $\Delta \geq 9$), where the fastest temporal path $P_{u,v}$ (in blue) from $u$ to $v$ is of duration $7$,
		while the fastest temporal path $P_{u,w}$ (in red) from $u$ to a vertex $w$, that is on a path $P_{u,v}$, is of duration $1$ and is not a subpath of $P_{u,v}$.		
		\label{fig:ftpExample}}
	\end{figure}

\begin{theorem}[$\star$]\label{thm:FPTwrtFES}
    \deltaExact\ is in FPT when parameterized by the feedback edge number of the underlying graph.
\end{theorem}

From \cref{thm:W1wrtFVS} and \cref{thm:FPTwrtFES} we immediately get the following, which is the main result of the paper.

\begin{corollary}
\deltaExact\ is:
\begin{itemize}
    \item in FPT when parameterized by the \emph{feedback edge number} or any larger parameter, such as the \emph{maximum leaf number}.
    \item W[1]-hard when parameterized by the \emph{feedback vertex number} or any smaller parameter, such as: 
    \emph{treewidth}, 
    \emph{degeneracy}, 
    \emph{cliquewidth}, 
    \emph{distance to chordal graphs}, and 
    \emph{distance to outerplanar graphs}.
\end{itemize}
\end{corollary}

Before presenting the structure of our algorithm for \cref{thm:FPTwrtFES}, observe that, in a static graph, the number of paths between two vertices can be upper-bounded by a function $f(k)$ of the feedback edge number $k$ of the graph~\cite{casteigts2021finding}. 
Therefore, for any fixed pair of vertices $u$ and $v$, we can ``guess'' the edges of the fastest temporal path from $u$ to $v$ (by guess we mean enumerate and test all possibilities).
However, 
% due to the difficulties illustrated in~\cref{fig:ftpExample}, 
for an FPT algorithm with respect to $k$, we cannot afford to guess the edges of the fastest temporal path for each of the $O(n^2)$ pairs of vertices. 
To overcome this difficulty, our algorithm follows this high-level strategy:
\begin{itemize}
    %%%\item We perform a preprocessing step by iteratively removing all vertices of degree one.
    \item We identify a small number $f(k)$ of ``important vertices''.
    \item For each pair $u,v$ of important vertices, we guess the edges of the fastest temporal path from $u$ to $v$ (and from $v$ to $u$).
    \item From these guesses we can still not deduce the edges of the fastest temporal paths between many pairs of non-important vertices. However, as we prove, it suffices to guess only a small number of specific auxiliary structures (to be defined later).
    \item From these guesses we deduce fixed relationships between the labels of most of the edges of the graph. 
    \item For all the edges, for which we have not deduced a label yet, we introduce a \emph{variable}. With all these variables, we build an Integer Linear Program (ILP). 
    Among the constraints in this ILP we have that, for each of the $O(n^2)$ pairs of vertices $u,v$ in the graph, the duration of one specific temporal path from $u$ to $v$ (according to our guesses) is \emph{equal} to the desired duration $D_{u,v}$, while the duration of each of the other temporal path from $u$ to $v$ is \emph{at least} $D_{u,v}$.
    \item 
    %%%By making any of the above guesses, we restrict the solution space for the problem \deltaExact. This restricted solution space coincides with the set of feasible solutions to the resulting ILP. Furthermore, the set of feasible solutions for all constructed ILPs coincide with the set of all solutions to \deltaExact\ (\ie regardless of our guesses). 
    By making each of the above combinations of guesses, we essentially enumerate all possible ways that our instance of \deltaExact\ has a solution, and for each of these possible ways we create an ILP. That is, our instance of \deltaExact\ has a solution if and only if at least one of these ILPs has a feasible solution.
    As each ILP can be solved in FPT time with respect to $k$ by Lenstra's Theorem~\cite{Lenstra1983Integer} (the number of variables is upper bounded by a function of $k$), we obtain our FPT algorithm for \deltaExact\ with respect to $k$.
\end{itemize}


We now present the first part of our FPT algorithm, that is, identifying important vertices and guessing information about the fastest temporal paths. A full description of the algorithm is deferred to the full paper~\cite{fullPaper}.

\begin{figure}[t]
	\centering
	\includegraphics[width=0.8\columnwidth]{fig-example-names-vertices_new}
	\caption{An example of a graph with its important vertices: $U$ (in blue), $U^*$ (in green) and $Z^*$ (in orange).
    Corresponding feedback edges are marked with a thick red line, while dashed edges represent the edges (and vertices) ``removed'' from $G'$ at the initial step.
	\label{fig:labelingVertices}}
\end{figure}

\subparagraph{Important vertices.}
Let $D$ be the input matrix of \deltaExact, and let $G$ be its underlying graph, on $n$ vertices and $m$ edges.
%\subsubsection*{Preprocessing of the input}
From the underlying graph $G$ of $D$ we first create a graph $G'$ by
iteratively removing vertices of degree one from $G$,
and denote with 
$
Z = V(G) \setminus V(G')
$, the set of removed vertices.
%Then we determine a minimum feedback edge set $F$ of $G'$.
%by finding a spanning tree $T$ of $G'$ and set $F = E(G) \setminus E(T)$. 
%Note that $F$ is also a minimum feedback edge set of $G$.
Then we determine the set $U$ (the \emph{``vertices of interest''}), and the set $U^*$ (the neighbors of the vertices of interest), as follows.
Let $T$ be a spanning tree of $G'$, with $F$ being the corresponding feedback edge set of $G'$.
Let $V_1 \subseteq V(G')$ be the set of leaves in the spanning tree $T$, $V_2 \subseteq V(G')$ be the set of vertices of degree two in $T$ which are incident to at least one edge in $F$, 
and let $V_3 \subseteq V(G')$ be the set of vertices of degree at least $3$ in $T$. 
Then $|V_1| + |V_2| \leq 2k$, since every leaf in $T$ and every vertex in $V_2$ is incident to at least one edge in $F$,
and $|V_3| \leq |V_1|$ by the properties of trees.
We denote with 
\[U = V_1 \cup V_2 \cup V_3\]
the set of \emph{vertices of interest}. It follows that $|U| \leq 4k$.
We set $U^*$ to be the set of vertices in $V(G') \setminus U$ that are neighbors of vertices in $U$, \ie 
\[U^* = \{v \in V(G') \setminus U  :  u \in U, v \in N(u)\}.\]
Again, using the tree structure, we get that for any $u \in U$ its neighborhood is of size $|N(u)| \in O(k)$, since every neighbor of $u$ is the first vertex of a (unique) path to another vertex in $U$.
It follows that $|U^*| \in O(k^2)$.
From the construction of~$Z$ (\ie by exhaustively removing vertices of degree one from~$G$), it follows that $G[Z]$ (the graph induced in $G$ by~$Z$) is a forest, \ie consists of disjoint trees. 
Each of these trees has a unique neighbor $v$ in~$G'$. 
Denote by $T_v$ the tree obtained by considering such a vertex $v$ and all the trees from $G[Z]$ that are incident to $v$ in $G$. 
We then refer to $v$ as the \emph{clip vertex} of the tree $T_v$.
In the case where $v$ is a vertex of interest we define also the set $Z^*_v$ of \emph{representative vertices} of~$T_v$, as follows.
%
We first create an empty set $C_w$ for every vertex $w$ that is a neighbor of $v$ in~$G'$.
We then iterate through every vertex $r$ that is in the first layer of the tree $T_v$ (\ie vertex that is a child of the root $v$ in the tree $T_v$), check the matrix $D$ and find the vertex~$w \in N_{G'}(v)$ that is on the smallest duration from $r$.
In other words, for an $r \in N_{T_v}(v)$ we find $w \in N_{G'}(v)$ such that $D_{r,w} \leq D_{r,w'}$ for all $w' \in  N_{G'}(v)$.
%
We add vertex $r$ to $C_w$.
In the case when there exists also another vertex $w' \in  N_{G'}(v) $ for which $D_{r,w'} = D_{r,w}$, we add $r$ also to the set $C_{w'}$. In fact, in this case $C_{w'} = C_w$.
At the end we create $|N_{G'}(v)| \in O(k)$ sets $C_w$, whose union contains all children of $v$ in $T_v$. 
For every two sets $C_w$ and $C_{w'}$, where $w,w'\in N_{G'}(v)$, we have that either $C_w = C_{w'}$, or $C_w \cap C_{w'} = \emptyset$. 
We interpret each of these sets $\{C_w : w \in N_{G'}(v)\}$ as an \emph{equivalence class} of the neighbors of $v$ in the tree $T_v$. 
Now, from each equivalence class~$C_w$ we choose an arbitrary vertex $r_w \in C_w$ and put it into the set $Z^*_v$.
%
We repeat the above procedure for all trees $T_u$ with the clip vertex $u$ from $U$, and define $Z^*$ as 
\begin{equation}
    Z^* = \bigcup\limits_{v \in U} Z^*_v.
\end{equation}
%
Since $|U| \in O(k)$ and for each $u \in U$ it holds $|N_{G'}(u)| \in O(k)$, we get that $|Z^*| \in O(k^2)$. 
Finally, the set of \emph{important vertices} is defined as the set $U \cup U^{\ast} \cup Z^{\ast}$.
For an illustration see \cref{fig:labelingVertices}.



% \medskip 
% \noindent We can solve \deltaExact\  by 
% for every pair of vertices $v_i, v_j \in V(G)$ we
% \begin{itemize}
%     \item determine the underlying path $P$ of the fastest temporal path from $v_i$ to $v_j$,
% for which we introduce the equality constraint (\ie $d(P) = D_{v_i, v_j}$), and %in the ILP
% \item make sure that every other path $P'$ from $v_i$ to $v_j$ is not faster than $P$ (\ie $d(P') \geq D_{v_i, v_j}$). %in the ILP
% \end{itemize}
% One could easily achieve this by ``guessing'' the fastest paths among each pair of vertices, but this would result in too many guesses. 
% With this in mind we create the following guesses.


\subparagraph{Guesses.} 
For every pair of important vertices $u,v \in U \cup U^{\ast} \cup Z^{\ast}$, we guess the sequence of edges in the fastest temporal path from $u$ to $v$. Since $U \cup U^{\ast} \cup Z^{\ast}\in O(k^2)$ and there are $k^{O(k)}$ possibilities for a sequence of edges between a fixed vertex pair, we have $k^{O(k^5)}$ overall possible guesses. We  defer further details to the full paper~\cite{fullPaper} (see guesses \textcolor{lipicsGray}{\textsf{\textbf{G-1}}} to \textcolor{lipicsGray}{\textsf{\textbf{G-6}}}).

\setcounter{guesscounter}{6}

\begin{figure}[t]
	\centering
	\includegraphics[width=0.75\columnwidth]{fig-exampleg10}
	\caption{In the above graph vertices $v_1, v_{11}, w$ are in $U$, while $v_2, v_{10}$ are in $U^*$. 
		Numbers above all $v_i$ represent the values of the fastest temporal paths from $w$ to each of them (\ie the entries in the $w$-th row of matrix $D$).
		From the basic guesses we know the fastest temporal path $P$ from $w$ to $v_2$ (depicted in blue) and the fastest temporal path $Q$ from $w$ to $v_{10}$.
		From the values of durations from $w$ to each $v_i$ we cannot 
		determine the fastest paths from $w$ to all $v_i$.
		More precisely, we know that $w$ reaches $v_2, v_3, v_4, v_5$ (resp.~$v_{10}, v_{9}, v_{9}, v_{7}$) 
		by first using the path $P$ (resp.~$Q$) and then proceeding through the vertices,
		but we do not know how $w$ reaches $v_6$ the fastest.
		Therefore we have to introduce some more guesses.
  \label{fig:guesses-advanced}}
\end{figure}

With the information provided by the described guesses we are still not able to determine all fastest paths. For example consider the case depicted in \cref{fig:guesses-advanced}. 
Therefore we introduce additional guesses that provide us with sufficient information to determine all fastest paths. To do this we have to first define the following.
\begin{definition}\label{def:segments}
	Let $U \subseteq V(G')$ be a set of vertices of interest and let $u,v \in U$.
	A path $P = (u=v_1,v_2, \dots, v_p = v)$ of length at least $2$ in graph $G'$, where all inner vertices are not in $U$, \ie $v_i \notin U$ for all $i \in \{ 2, 3, \dots, p-1\}$,
	is called a \emph{segment} from $u$ to $v$. We denote it as $S_{u,v}$.
\end{definition}
Note by \cref{def:segments} that $S_{u,v} \neq S_{v,u}$. 
Observe that a temporal path in $G'$ between two vertices of interest is either a segment, or it consists of a sequence of some segments. Furthermore, since we have at most $4k$ interesting vertices in $G'$, we can deduce the following important result.
\begin{corollary}\label{obs:FPT-k2segments}
	There are $O(k^2)$ segments in $G'$.
\end{corollary}
% We now continue with our guessing.
To describe the next guesses, we introduce the following notation. Let $u,v,x$ be three vertices in $G'$. We write $u \leadsto x \rightarrow v$ to denote a temporal path from $u$ to $v$ that passes through $x$, and then goes to $v$ (via one edge).
%In the case when we want to guess the fastest path from $u$, that passes through vertex $x$ (not necessarily via one edge), and then goes directly to $v$ (via one edge), we write it as a fastest path of the form $u \leadsto x \rightarrow v$.
We guess the following structures.
\begin{enumerate}[G-1.]
	\setcounter{enumi}{\value{guesscounter}}
	\item \label{FPT-guessFTPamongv2z2}
	\textbf{Inner segment guess I}.
	Let $S_{u,v} = (u=v_1,v_2, \dots, v_p = v)$ and $S_{w,z} = (w=z_1,z_2, \dots, z_r = z)$ be two segments in $G'$. %,
	%first one between vertices $u,v \in U$, second one between vertices $w, z \in U$.
	We want to guess the fastest temporal path
	$v_2 \rightarrow u \leadsto w \rightarrow z_2$. 
	We repeat this procedure for all pairs of segments.
	Since there are $O(k^2)$ segments in $G'$,
	there are $k^{O(k^5)}$ possible paths of this form. \\
	Recall that $S_{u,v}\neq S_{v,u}$ for every $u,v\in U$. Furthermore note that we did not assume that $\{u,v\} \cap \{w,z\} = \emptyset$. Therefore, by repeatedly making the above guesses, we also guess the following fastest temporal paths: 
	${v_2 \rightarrow u \leadsto z \rightarrow z_{r-1}}$,\ \ \ 
	${v_2 \rightarrow u \leadsto v \rightarrow v_{p-1}}$,\ \ \  
	${v_{p-1} \rightarrow v \leadsto w \rightarrow z_{2}}$,\ \ \  
	${v_{p-1} \rightarrow v \leadsto z \rightarrow z_{r-1}}$, and  
	${v_{p-1} \rightarrow v \leadsto u \rightarrow v_{2}}$.
	%
	For an example see~\cref{fig:FPT-guessG4}.
	\item \label{FPT:guess-uToSegmentz2}
	\textbf{Inner segment guess II}.
	Let $S_{u,v} = (u=v_1,v_2, \dots, v_p = v)$ be a segment in $G'$,
	and let $w \in U \cup Z^*$. %be either a vertex of interest or a representative vertex of a tree, whose clipped vertex is a vertex of interest.
	We want to
	guess the following fastest temporal paths
	$w \leadsto u \rightarrow v_2$, $w \leadsto v \rightarrow v_{p-1} \rightarrow \cdots \rightarrow v_2$,
	and
	$v_2 \rightarrow u \leadsto w$, $v_2 \rightarrow v_3 \rightarrow \cdots v \leadsto w$.
	\\
	For fixed $S_{u,v}$ and $w \in U \cup Z^*$ we have $k^{O(k)}$ different possible such paths, therefore we make $k^{O(k^5)}$ guesses for these paths.
	%
	For an example see~\cref{fig:FPT-guessG5}.
	%All together we made $O(k^{k^4}$  new guesses for the structure of all of the above mentioned fastest temporal paths.
	%Each of the previous partial ILP instances is therefore extended into $O(k^6)$ new ILP instances.
	\item \label{FPT:guess-splitFromAnotherSegmentAndPaths}
	\textbf{Split vertex guess I}.
	Let $S_{u,v} = (u=v_1,v_2, \dots, v_p = v)$ be a segment in $G'$, and let us
	fix a vertex $v_i \in S_{u,v} \setminus \{u,v\}$.
	In the case when $S_{u,v}$ is of length $4$, the fixed vertex $v_i$ is the middle vertex, else we fix an arbitrary vertex $v_i \in S_{u,v} \setminus \{u,v\}$.
	Let 
	$S_{w,z} = (w=z_1,z_2, \dots, z_r = z)$ be another segment in $G'$.
	We want to determine the fastest paths from $v_i$ to all inner vertices of $S_{w,z}$. We do this by inspecting the values in matrix $D$ from $v_i$ to inner vertices of $S_{w,z}$.
	We split the analysis into two cases.
	\begin{enumerate}
		\item 
		There is a single vertex $z_j \in S_{w,z}$ for which the duration from $v_i$ is the biggest.
		More specifically, $z_j \in S_{w,z} \setminus \{w,z\}$ is the vertex with the biggest value  $D_{v_i,z_j}$.
		We call this vertex a \emph{split vertex of $v_i$ in the segment $S_{wz}$}.
		Then it holds that $D_{v_i,z_2} < D_{v_i,z_3} < \dots < D_{v_i,z_j}$ and 
		$D_{v_i,z_{r-1}} < D_{v_i,z_{r-2}} < \dots < D_{v_i,z_j}$.
		From this it follows that the fastest temporal paths from $v_i$ to $z_2, z_3, \dots, z_{j-1}$ go through $w$,
		and 
		the fastest temporal paths from $v_i$ to $z_{r-1}, z_{r-2}, \dots, z_{j+1}$ go through $z$.
		We now want to guess which vertex $w$ or $z$ is on a fastest temporal path from $v_i$ to $z_j$.
		Similarly,
		all fastest temporal paths starting at $v_i$ have to go either through $u$ or through $v$,
		which also gives us two extra guesses for the fastest temporal path from $v_i$ to $z_j$.
		Therefore, all together we have $4$ possibilities on how the fastest temporal path from $v_i$ to $z_j$ starts and ends.
		Besides that we want to guess also how the fastest temporal paths from $v_i$ to $z_{j-1}, z_{j+1}$ start and end.
		Note that one of these is the subpath of the fastest temporal path from $v_i$ to $z_j$, and the ending part is uniquely determined for both of them,
		\ie to reach $z_{j-1}$ the fastest temporal path travels through $w$, and to reach $z_{j+1}$ the fastest temporal path travels through $z$.
		Therefore we have to determine only how the path starts, namely if it travels through $u$ or $v$.
		This introduces two extra guesses.
		For a fixed $S_{u,v}, v_i$ and $S_{w,z}$ we find the vertex $z_j$ in polynomial time, 
		or determine that $z_j$ does not exist.
		We then make four guesses where we determine how the fastest temporal path from $v_i$ to $z_j$ passes through vertices $u,v$ and $w,z$ and 
		for each of them two extra guesses to determine the fastest temporal path from $v_i$ to $z_{j-1}$ and from $v_i$ to $z_{j+1}$.
		We repeat this procedure for all pairs of segments,
		which results in producing $k^{O(k^5)}$ new guesses.
		Note, $v_i \in S_{u,v}$ is fixed when calculating the split vertex for all other segments $S_{w,z}$.
		\item 
		There are two vertices $z_j, z_{j+1} \in S_{w,z}$ for which the duration from $v_i$ is the biggest.
		More specifically, $z_j, z_{j+1} \in S_{w,z} \setminus \{w,z\}$ are the vertices with the biggest value  $D_{v_i,z_j} = D_{v_i,z_{j+1}}$.
		Then it holds that $D_{v_i,z_2} < D_{v_i,z_3} < \dots < D_{v_i,z_j} = D_{v_i,z_{j+1}} > D_{v_i,z_{j + 2}} > \cdots > D_{v_i,z_{r-1}}$.
		From this it follows that the fastest temporal paths from $v_i$ to $z_2, z_3, \dots, z_{j}$ go through $w$,
		and 
		the fastest temporal paths from $v_i$ to $z_{r-1}, z_{r-2}, \dots, z_{j+1}$ go through $z$.
		In this case we only need to guess the following two fastest temporal paths 
		$v_i \leadsto w \rightarrow z_2$
		and $v_i \leadsto z \rightarrow z_{r-1}$.
		Each of these paths we then uniquely extend along the segment $S_{w,z}$ up to the vertex $z_j$, resp.~$z_{j+1}$,
		which give us fastest temporal paths from $v_i$ to $z_j$ and from $v_i$ to $z_{j+1}$.
		In this case we introduce only two more guesses.
        We repeat this procedure for all pairs of segments. which results in creating $k^{O(k^5)}$ new guesses.
	\end{enumerate}
	%
	For an example see~\cref{fig:FPT-guessG5}.
	\item \label{FPT:guess-splitFromUtoAnotherSegment}
	\textbf{Split vertex guess II}.
	Let $w \in U \cup Z^*$ 
	and let $S_{u,v} = (u=v_1,v_2, \dots, v_p = v)$.
	We want to guess a split vertex of $w$ in $S_{u,v}$, and the fastest temporal path that reaches it.
	We again have two cases,
	first one where $v_i$ is a unique vertex in $S_{u,v}$ that is furthest away from $w$,
	and the
	second one where $v_i, v_{i+1}$ are two incident vertices in $S_{u,v}$, that are furthest away from $w$.
	All together we make two guesses for each pair $w, S_{u,v}$.
	We repeat this for all vertices in $U \cup Z^*$, and all segments,
	which produces $k^{O(k^5)}$ new guesses.
	%
	For an example see~\cref{fig:FPT-guessG6}.
	Detailed analysis follows arguing from above (as in \textcolor{lipicsGray}{\textsf{\textbf{G-\ref{FPT:guess-splitFromAnotherSegmentAndPaths}}}}) and is deferred to the full paper~\cite{fullPaper}.
	% counter for guesses continues
	\setcounter{guesscounter}{\value{enumi}}
\end{enumerate}
%

\begin{figure}[t]
	\centering
	\begin{subfigure}[b]{0.48\textwidth}
		\centering
		\resizebox{0.88\linewidth}{!}{
			\includegraphics{fig-guess1}}
		\caption{Example of an Inner segment guess I (\textcolor{lipicsGray}{\textsf{\textbf{G-\ref{FPT-guessFTPamongv2z2}}}}), where we guessed the fastest temporal paths of the form $v_2 \rightarrow u \leadsto w \rightarrow z_2$ (in blue)
			and $v_2 \rightarrow u \leadsto z \rightarrow z_{r-1}$ (in red).
			\label{fig:FPT-guessG4}}
	\end{subfigure}
	\quad
	\begin{subfigure}[b]{0.48\textwidth}
		\centering
		\resizebox{0.88\linewidth}{!}{
			
			\includegraphics{fig-guess2}}
		\caption{Example of an Inner segment guess II (\textcolor{lipicsGray}{\textsf{\textbf{G-\ref{FPT:guess-uToSegmentz2}}}}), where we guessed the fastest temporal paths of the form $w \leadsto u \rightarrow v_2$ (in blue) and $w \leadsto v \rightarrow v_{p-1}$ (in red). 
			\label{fig:FPT-guessG5}}
	\end{subfigure}
	
	\begin{subfigure}[b]{0.48\textwidth}
		\vspace{-0.4cm}
        \centering
		\resizebox{0.98\linewidth}{!}{
			%
			\includegraphics{fig-guess3}}
		\caption{Example of a Split vertex guess I (\textcolor{lipicsGray}{\textsf{\textbf{G-\ref{FPT:guess-splitFromAnotherSegmentAndPaths}}}}), where, for a fixed vertex $v_i \in S_{u,v}$,
			we calculated its corresponding split vertex $z_j \in S_{w,z}$,
			and guessed the fastest paths of the form
			$v_i \rightarrow v_{i-1} \rightarrow \cdots \rightarrow u \leadsto z \rightarrow z_{r-1} \cdots \rightarrow z_j$ (in blue) 
			and $v_i \rightarrow v_{i+1} \rightarrow \cdots \rightarrow v \leadsto w \rightarrow z_2 \rightarrow \cdots \rightarrow z_{j-1}$ (in red). 
			\label{fig:FPT-guessG6}}
	\end{subfigure}
	\quad
	\begin{subfigure}[b]{0.48\textwidth}
		\centering
		\resizebox{0.88\linewidth}{!}{
			\includegraphics{fig-guess4}}
		\caption{Example of a Split vertex guess II (\textcolor{lipicsGray}{\textsf{\textbf{G-\ref{FPT:guess-splitFromUtoAnotherSegment}}}}), where, for a vertex of interest $w$, 
			we
			calculated its corresponding split vertex $v_i \in S_{u,v}$,
			and guessed the fastest paths of the form
			$w \leadsto u \rightarrow v_2 \rightarrow \cdots \rightarrow v_i$  (in blue) 
			and $w \leadsto v \rightarrow v_{p-1} \rightarrow \cdots \rightarrow v_{i+1}$ (in red). 
			\label{fig:FPT-guessG7}}
	\end{subfigure}
	\caption{Illustration of the guesses \textcolor{lipicsGray}{\textsf{\textbf{G-\ref{FPT-guessFTPamongv2z2}}}}, \textcolor{lipicsGray}{\textsf{\textbf{G-\ref{FPT:guess-uToSegmentz2}}}}, \textcolor{lipicsGray}{\textsf{\textbf{G-\ref{FPT:guess-splitFromAnotherSegmentAndPaths}}}}, and \textcolor{lipicsGray}{\textsf{\textbf{G-\ref{FPT:guess-splitFromUtoAnotherSegment}}}}.}
\end{figure}

There are two more guesses \textcolor{lipicsGray}{\textsf{\textbf{G-11}}} and \textcolor{lipicsGray}{\textsf{\textbf{G-12}}} that are deferred to the full paper~\cite{fullPaper}. 
We prove in~\cite{fullPaper} that, for all guesses \textcolor{lipicsGray}{\textsf{\textbf{G-1}}} to \textcolor{lipicsGray}{\textsf{\textbf{G-12}}}, there are in total at most $f(k)$ possible choices, and for each one of them we create an ILP with at most $f(k)$ variables and at most $f(k)\cdot |D|^{O(1)}$ constraints. Each of these ILPs can be solved in FPT time by Lenstra's Theorem~\cite{Lenstra1983Integer}.
%We create all of the above guesses independently.
%We start with the first one, that results in $O(k^{k^3})$ different possibilities, then we split each one of these guesses into $O(k^{k^3})$ new ones, that respond to the guessing in the second step, etc.
%After creating all of the guesses we end up with $f(k)$ different cases (where $f$ is a double exponential) 
%and create one ILP instance for each case.
%
%For each of the ILP instances we iterate through all pairs of vertices $u,v \in V(G)$ and, using the above guesses, determine, not only the fastest path $P$ from $u$ to $v$, but also all other paths $P'_i$.
%For the labels of edges of the fastest path $P$ we introduce the equality constraint, while for the labels of the edges of all other paths $P'_i$ we introduce the inequality constraint (\ie the duration $d(P_i')$ of any $P'_i$ cannot be smaller than $d(P)=D_{u,v}$).
%We can do this efficiently, while introducing only a small number of variables,
%which ensures that each ILP is solved in an FPT-time.
For detailed explanation and proofs of this part see~\cite{fullPaper}.


\section{Conclusion}\label{sec:conclusion}
We believe that our work spawns several interesting future research directions and builds a base upon which further temporal graph realization problems can be investigated.

%\subparagraph{Further parameterizations.} 
There are several structural parameters which can be considered to obtain tractability which are either larger than or incomparable to the feedback vertex number. We believe that the \emph{vertex cover number} or the \emph{tree depth} are promising candidates.
Furthermore, we can consider combining a structural parameter such as the \emph{treewidth} with $\Delta$.

%\subparagraph{Further problem variants.}
There are many natural variants of our problem that are well-motivated and warrant consideration. 
%In the following, we give two specific examples. 
We believe that one of the most natural generalizations of our problem is to allow more than one label per edge in every $\Delta$-period. A well-motivated variant (especially from the network design perspective) of our problem would be to consider the entries of the duration matrix $D$ as upper-bounds on the duration of fastest paths rather than exact durations. 
%Our work gives a starting point for many interesting future research directions such as the two mentioned examples.



\bibliography{bibliography}	


%\clearpage

%\appendix


\end{document}